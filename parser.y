/* This block of code will go into the header file generated by bison */
%code requires{

   #include "typedefs.h"
   #include "BreakTrace.h"
   #include "mc6809dbg.h"   
   #include "termdbg.h"

   typedef struct RegId { int id; } sRegId;
}

/* This block will be put into the cpp source code */
%{
#include <stdio.h>
#include <stdlib.h>

//#include "lexer.hpp"
extern int yylex();
#include "hexadump.h"
#include "mc6809dbg.h"   
#include "termdbg.h"
#include "mc6850.h"
#include "memory.h"
#include "Symbol.h"

const int max_values = 64;
int value_ix = 0;
int values[max_values];

void yyerror(mc6809dbg cpu, TerminalDbg term, const char *msg);

void do_hexadump(mc6809& cpu, int nBytes, int addr)
{
   Byte buffer[1024];
   if (nBytes > 1024)
      nBytes = 1024;

   for(int i = 0; i < nBytes; i++)
      buffer[i] = cpu.read(addr+i);
   hexdump((char*)buffer, nBytes, addr);
}

%}

%parse-param  {mc6809dbg &cpu} {TerminalDbg &term}

%union{
  int ival;
  sRegId reg_id;
  SRange range;
  EBrkTyp brk_typ;
  char string[80];
}

//%error-verbose
%define parse.error verbose
%define parse.trace
%locations

%start input
%token EQ MULT DIV MOD PLUS MINUS NOT LSL LSR OR XOR AND L_PAREN R_PAREN END
%token STEP GO REGS RESET EVAL DUMP LEN TO TRACE CLEAR BREAK TBF HELP QUIT
%token BYTE WORD ASM OCCURS LOAD BASE APPEND SYMBOLS
%token RD RX RY RU RS RPC RA RB RCC RDP


%token <ival> NUMBER
%token <reg_id> REGID
%token <brk_typ> XRWA
%token <string> FILENAME SYMBOL

%type <ival> exp opt_count occurs opt_base opt_append
%type <reg_id> register
%type <range> range_len opt_len_to

%left OR XOR 
%left AND
%left LSL LSR 
%left PLUS MINUS
%left MULT DIV

%left NOT
%nonassoc UMINUS

%% 
input:	{  }
			| input line
			;

line:		stmt END 
         | stmt error END
             {
               yyerrok;
             }
         | /*empty */ END 
         ;

stmt:      exp                      { fprintf(stderr, "%04X\n", $1);}
         | EVAL exp                 { 
                                       fprintf(stderr, "\t");
                                       for(DWord mask = 0x00008000; mask; mask = mask>>1)
                                          fprintf(stderr, "%c", (mask & (DWord)$2)?'1':'0'); 
                                       fprintf(stderr, "\t0%o\t%d\t$%0x\t'%c'\n", $2, $2, $2, isprint($2)?$2:'_'); }
         | STEP opt_count           { cpu.tron(); term.set_exec(); for(int i=0; i<$2; i++) cpu.tick(); term.set_debug(); cpu.troff(); }
         | GO                       { cpu.troff(); term.set_exec(); cpu.run(); term.set_debug(); }
			| REGS                     { cpu.regs(); }
         | RESET                    { cpu.reset(); }
         | register EQ exp               
            {
               if ($1.id <= 5)
                  cpu.wordrefreg($1.id) = $3;
               else
                  cpu.byterefreg($1.id) = $3;
            }  
         | TRACE trace_tail
         | BREAK break_tail
         | HELP { cpu.help(); }
         | QUIT { exit(0); }
         | BYTE range_len EQ exp_list  { if ($2.def) $2.len = value_ix; cpu.cmdByteWrite($2, values,  value_ix); }
         | WORD range_len EQ exp_list  { if ($2.def) $2.len = value_ix; cpu.cmdWordWrite($2, values,  value_ix); }
         | DUMP range_len              { cpu.cmdDumpBytes($2); }
         | BYTE range_len              { cpu.cmdDumpBytes($2); }
         | WORD range_len              { if ($2.def) $2.len=8; cpu.cmdDumpWords($2); }
         | ASM  range_len              { cpu.cmdDisassemble($2); }
         | LOAD FILENAME opt_base opt_append { cpu.cmdLoadFilename($2, $3, $4); }
         | SYMBOLS symbol_tail
         ;

exp:		  NUMBER                   { $$ = $1; }

         | exp OR exp               { $$ = $1 | $3; }
         | exp XOR exp              { $$ = $1 ^ $3; }
         | exp AND exp              { $$ = $1 & $3; }

			| exp PLUS exp             { $$ = $1 + $3; }
			| exp MINUS exp            { $$ = $1 - $3; }
			| exp MULT exp             { $$ = $1 * $3; }
         | exp DIV exp              { if ($3==0) yyerror(cpu, term, "divide by zero"); else $$ = $1 / $3; }
         | exp MOD exp              { if ($3==0) yyerror(cpu, term, "divide by zero"); else $$ = $1 % $3; }
         | NOT exp                  { $$ = ~$2; }
         | MINUS exp %prec UMINUS   { $$ = -$2; }
			| L_PAREN exp R_PAREN      { $$ = $2; }

         | exp LSL exp              { $$ = $1 << $3; }
         | exp LSR exp              { $$ = $1 >> $3; }

         | register                 
            {
               if ($1.id <= 5)
                  $$ = cpu.wordrefreg($1.id);
               else
                  $$ = cpu.byterefreg($1.id);
            }        
			| SYMBOL { $$ = getSymbolAddr(cpu, term, $1); }
         ;

symbol_tail:
                 { dispSymbols(); }
   | FILENAME    { cpu.showSymbolsByTextMatch($1); }
   | range_len   { cpu.showSymbolsByAddressRange($1); }
   ;

opt_count:
     { $$ = 1; }
  | exp        { $$ = $1; }
  ;

register: REGID { $$ = $1; } ;


range_len:
     exp opt_len_to
         { 
            $$.addr = $1;
            $$.def = $2.def;
            $$.typeTo = $2.typeTo;
            if ($2.typeTo) $$.to = $2.to; 
            else           $$.len = $2.len;
         }
     ;

opt_len_to:
              {$$.len = 16; $$.typeTo = false; $$.def = true;  }
   | LEN exp  {$$.len = $2; $$.typeTo = false; $$.def = false; }
   | TO exp   {$$.to = $2;  $$.typeTo = true;  $$.def = false; }
   ;

trace_tail: 
                              { cpu.dispTrace(16); }
         | exp opt_len_to     { 
                                 if ($2.def) 
                                    cpu.dispTrace($1);
                                 else
                                    if ($2.typeTo)
                                       cpu.dispTrace($1, $2.len);
                                    else
                                       cpu.dispTrace($1, $1+$2.len);
                              }
         | CLEAR              { cpu.clearTrace(); }
         ;

break_tail:
                            { cpu.dispBreak(); }
      | exp occurs          { cpu.SetBreakOnExec($1, $2); }
      | exp XRWA occurs     { cpu.SetBreakOnExec($1, $2, $3); }
      | exp XRWA exp occurs { cpu.SetBreakOnExec($1, $2, $4, $3); }
      | CLEAR exp           { cpu.UnsetBreak($2); }
      | TBF                 { cpu.SetBreakOnTraceBufferFull(); }
      ;

occurs:
                { $$ = 0; }
   | OCCURS exp { $$ = $2; }


exp_list:
     exp { value_ix = 0; values[value_ix++] = $1; }
   | exp_list exp { values[value_ix++] = $2; }
   ;

opt_base:
               { $$ = 0; }
   | BASE exp  { $$ = $2; }
   ;

opt_append:
            { $$ = 0; }
   | APPEND { $$ = 1; }
   ;

%%

void yyerror(mc6809dbg cpu, TerminalDbg term, const char *msg)
{
   (void)cpu;
   (void)term;
//   fprintf(stderr, "** yytext:%s\n", yytext);
   fprintf(stderr, "** Line %d: %s\n", yylloc.first_line, msg);
}

